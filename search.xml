<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[从前端菜鸟到大神，一篇总结得很好的文章]]></title>
      <url>/2017/04/26/hello-world/</url>
      <content type="html"><![CDATA[<p>摘要:转载自：<a href="https://github.com/qiu-deqing/FE-learning" target="_blank" rel="external">https://github.com/qiu-deqing/FE-learning</a><br><a id="more"></a><br>正文:结合个人经历总结的前端入门方法，总结从零基础到具备前端基本技能的道路、学习方法、资料。由于能力有限，不能保证面面俱到，只是作为入门参考，面向初学者，让初学者少走弯路。</p>
<p>互联网的快速发展和激烈竞争，用户体验成为一个重要的关注点，导致专业前端工程师成为热门职业，各大公司对前端工程师的需求量都很大，要求也越来越高，优秀的前端工程师更是稀缺。个人感觉前端入门相对容易，但是也需要系统地认真学习，在打好基础后坚持学习，成为优秀前端工程师也只是时间问题。</p>
<p>学习任何知识最重要的都是兴趣，如果经过一段时间的学习感觉不喜欢，那可能强迫自己学习是很痛苦的，效果也不会好，毕竟这很可能就是以后很多年生存的技能。不过随着互联网行业的发展，前端必然是Web开发人员需要学习的知识，有时候是没有专业前端工程师一起合作的，所以即使不做专门的前端工程师，掌握基本的前端技能为工作带来方便。</p>
<p>后期邀请了一些同学分享学习经历。如果有同学愿意分享,欢迎push</p>
<p>必备基础技能</p>
<p>前端技能汇总（<a href="https://github.com/JacksonTian/fks）这个项目详细记录" target="_blank" rel="external">https://github.com/JacksonTian/fks）这个项目详细记录</a> 了前端工程师牵涉到的各方面知识。在具备基本技能之后可以在里面找到学习 的方向，完善技能和知识面。</p>
<p>frontend-dev-bookmarks（<a href="https://github.com/dypsilon/frontend-dev-bookmarks）是老外总结的前端开发资源。覆盖面非常广。包括各种知识点、工具、技术，非常全面。" target="_blank" rel="external">https://github.com/dypsilon/frontend-dev-bookmarks）是老外总结的前端开发资源。覆盖面非常广。包括各种知识点、工具、技术，非常全面。</a></p>
<p>以下是个人觉得入门阶段应该熟练掌握的基础技能：</p>
<p>HTML4，HTML5语法、标签、语义<br>CSS2.1，CSS3规范，与HTML结合实现各种布局、效果<br>Ecma-262定义的javascript的语言核心，原生客户端javascript，DOM操作，HTML5新增功能<br>一个成熟的客户端javascript库，推荐jquery<br>一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟，<br>HTTP</p>
<p>在掌握以上基础技能之后，工作中遇到需要的技术也能快速学习。</p>
<p>基本开发工具</p>
<p>恰当的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并 解决问题，以下是个人觉得必备的前端开发工具：</p>
<p>文本编辑器：推荐Sublime Text，支持各种插件、主题、设置，使用方便<br>浏览器：推荐Google Chrome，更新快，对前端各种标准提供了非常好的支持<br>调试工具：推荐Chrome自带的Chrome develop tools，可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等<br>辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools，<br>FQ工具：lantern, 壁虎漫步</p>
<p>学习方法和学习目标</p>
<p>方法：</p>
<p>入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果<br>在具备一定基础之后可以上网搜各种教程、demo，了解各种功能的实际用法和常见功能的实现方法<br>阅读HTML，CSS，Javascript标准全面完善知识点<br>阅读前端牛人的博客、文章提升对知识的理解<br>善用搜索引擎</p>
<p>目标：</p>
<p>熟记前面知识点部分的重要概念，结合学习经历得到自己的理解<br>熟悉常见功能的实现方法，如常见CSS布局，Tab控件等。</p>
<p>入门之路</p>
<p>以下是入门阶段不错的书籍和资料</p>
<p>HTML先看《HTML &amp; CSS: Design and Build Websites》1-9章，然后《HTML5: The Missing Manual》1-4章。<br>CSS先看《CSS: The Missing Manual》，然后《CSS权威指南》<br>javascript先看《javascript高级程序设计》，然后《javascript权威指南》<br>HTTP看HTTP权威指南<br>在整个学习过程中HTML CSS JavaScript会有很多地方需要互相结合，实际工作中也是这样，一个简单的功能模块都需要三者结合才能实现。<br>动手是学习的重要组成部分，书籍重点讲解知识点，例子可能不是很充足，这就需要利用搜索引擎寻找一些简单教程，照着教程实现功能。以下是一些比较好的教程网址<br>可以搜索各大公司前端校招笔试面试题作为练习题或者他人总结的前端面试题还有个人总结的面试题（带参考答案）<br><a href="http://code.tutsplus.com有各种各样的教程" target="_blank" rel="external">http://code.tutsplus.com有各种各样的教程</a><br>MDN也有很多教程，更重要的是里面有详细的文档，需要查找某个功能时在Google搜索：xxx site:<a href="https://developer.mozilla.org" target="_blank" rel="external">https://developer.mozilla.org</a><br><a href="http://www5rocks.com/zh/也有很多优质教程" target="_blank" rel="external">http://www5rocks.com/zh/也有很多优质教程</a><br><a href="http://www.sitepoint.com/" target="_blank" rel="external">http://www.sitepoint.com/</a><br><a href="http://alistapart.com/" target="_blank" rel="external">http://alistapart.com/</a><br>原生javascript是需要重点掌握的技能，在掌握原生javascript的基础上推荐熟练掌握jQuery，在实际工作中用处很大，这方面的书籍有《Learning jQuery》或者去jQuery官网<br>建一个<a href="https://github.com/账号，保存平时学习中的各种代码和项目。" target="_blank" rel="external">https://github.com/账号，保存平时学习中的各种代码和项目。</a><br>有了一定基础之后可以搭建一个个人博客，记录学习过程中遇到的问题和解决方法，方便自己查阅也为其他人提供了帮助。也可以去<a href="http://www.cnblogs.com/或者http://www.csdn.net/这样的网站注册账号，方便实用" target="_blank" rel="external">http://www.cnblogs.com/或者http://www.csdn.net/这样的网站注册账号，方便实用</a><br>经常实用Google搜索英文资料应该经常找到来自<a href="http://stackoverflow.com/的高质量答案，与到问题可以直接在这里搜索，如果有精力，注册一个账号为别人解答问题也能极大提高个人能力。" target="_blank" rel="external">http://stackoverflow.com/的高质量答案，与到问题可以直接在这里搜索，如果有精力，注册一个账号为别人解答问题也能极大提高个人能力。</a><br>经典书籍熟读之后，可以打开前面必备基础技能部分的链接。认真读对应标准，全面掌握知识</p>
<p>继续提高</p>
<p>有了前面的基础之后，前端基本算是入门了，这时候可能每个人心中都有了一些学习方向，如果还是没有。 可以参考前面必备技能部分提到的那两个项目，从里面选一些进行发展学习。以下是一些不错的方面：</p>
<p>Grunt：前端自动化工具，提高工作效率<br>less css：优秀的CSS预处理器<br>bootstrap：优秀的CSS框架，对没有设计师的团队很不错，与less结合使用效果完美<br>requirejs：AMD规范的模块加载器，前端模块化趋势的必备工具<br>Node.js：JavaScript也可以做后台，前端工程师地位更上一步<br>AngularJS：做Single Page Application的好工具<br>移动端web开发：智能手机的普及让移动端的流量正在逐步赶超PC端<br>Javascript内存管理：SPA长期运行需要注意内存泄露的问题<br>High Performance JavaScript(Build Faster Web Application Interfaces)<br>Best Practices for Speeding Up Your Web Site：重要技能</p>
<p>一些个人经历</p>
<p>LingyuCoder的学习经历</p>
<p>上面的大神都总结得差不多了，我这里就胡扯一些吧</p>
<p>工具</p>
<p>chrome dev tools：前端开发调试利器，着重注意几个功能：<br>console（废话）<br>elements:元素样式调整，很常用<br>sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象<br>watch expression：通过表达式查看当前内存中的值<br>call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候）<br>scope variables：作用域链上的变量，非常有用<br>network：抓包查看每个请求，非常重要，前后端联调必备<br>timeline：分析渲染、js执行等等各个阶段，性能优化利器<br>emulation：模拟移动端环境，mobile页面开发必备<br>一些插件:<br>liveload: 修改页面后自动刷新，不用按F5<br>dimensions：直接在页面上测量的利器<br>livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中<br>image tool：测量，取色<br>UC二维码：移动端调试扫码必备<br>pagespeed，YSlow：页面性能分析和优化插件<br>马克飞象：优秀的在线markdown编辑器，快速写周报，做记录<br>sublime text2：编码方便，插件多，速度快，性能好<br>emmet：提升html编码速度必备<br>sublimelinter + 各种语言的lint和hint：代码纠错<br>一些snippets：自动补全，提升开发效率<br>Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能<br>Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件<br>GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子<br>iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备<br>Charles：Mac 平台最好用的抓包分析工具<br>Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用<br>Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便</p>
<p>技能</p>
<p>前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说</p>
<p>语言基础</p>
<p>JavaScript：</p>
<p>作用域链、闭包、运行时上下文、this<br>原型链、继承<br>NodeJS基础和常用API</p>
<p>CSS：</p>
<p>选择器<br>浏览器兼容性及常见的hack处理<br>CSS布局的方式和原理（盒子模型、BFC、IFC等等）<br>CSS 3，如animation、gradient、等等</p>
<p>HTML：</p>
<p>语义化标签</p>
<p>进阶</p>
<p>JavaScript:</p>
<p>异步控制（Promise、ES6 generator、Async）<br>模块化的开发方式（AMD、CMD、KMD等等）<br>JavaScript解释器的一些相关知识<br>异步IO实现<br>垃圾回收<br>事件队列<br>常用框架使用及其原理<br>jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研<br>AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦<br>underscore：优秀的工具库，方便的理解常用工具代码片段的实现<br>polymer/React: 组件化开发，面向未来，理解组件化开发的原理</p>
<p>CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理</p>
<p>DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程<br>解析HTML、CSS、JavaScript时造成的阻塞<br>HTML5相关<br>SVG及矢量图原理<br>Canvas开发及动画原理（帧动画）<br>Video和Audio<br>flex box布局方式<br>icon fonts的使用</p>
<p>常用NodeJs的package：</p>
<p>koa<br>express<br>underscore<br>async<br>gulp<br>grunt<br>connect<br>request</p>
<p>一些理念：</p>
<p>响应式Web<br>优雅降级、渐进增强<br>dont make me think<br>网页可用性、可访问性、其中的意义<br>SEO搜索引擎优化，了解搜索引擎的原理<br>SPA的好处和问题</p>
<p>性能优化：</p>
<p>减少请求数量（sprite、combo）<br>善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式）<br>减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离）<br>CSS的回流与重绘</p>
<p>项目</p>
<p>版本管理：首推Git，用过Git都不会想用SVN了<br>Git：本地版本管理的机制<br>SVN：远程中心的版本管理机制<br>自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并<br>Gulp：基于流构建，速度快、模块质量好<br>Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高<br>预处理和模板引擎<br>less：语法简单，但功能有限<br>jade、ejs、velocity等模板引擎，各有各的长处<br>coffee：python工程师最爱，我没用过<br>环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了<br>本地代理：ihosts<br>自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果<br>jasmine<br>mocha<br>生态系统<br>npm<br>bower<br>spm<br>搭建一个属于自己的博客<br>git pages<br>hexo<br>jekyll</p>
<p>未来</p>
<p>Web Componets：面向未来的组件化开发方式<br>HTML模板<br>Shadow DOM<br>Custom Elements<br>HTML Import<br>移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发</p>
<p>其他</p>
<p>有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方</p>
<p>对于业务的思考：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务<br>交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目<br>知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录<br>对新技术的渴望，以及敢于尝试</p>
<p>入门书</p>
<p>入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书：</p>
<p>《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看<br>《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助<br>《编写可维护的JavaScript》和：<br>《Node.js开发指南》：不错的Nodejs入门书籍<br>《深入浅出Node.js》：Nodejs进阶书籍，必备<br>《JavaScript异步编程》：理解JS异步的编程理念<br>《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书<br>《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西<br>《Dont make me think》：网页设计的理念，了解用户行为，非常不错<br>《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题<br>《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习<br>《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助<br>《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识<br>《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想<br>《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门</p>
<p>一些不错的网站</p>
<p>github：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习<br>codepen：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件<br>echojs：快速了解js新资讯的网站<br>stackoverflow和segmentfault：基本上各种问题都能在上面获得解答<br>google web fundamentals：每篇文章都适合仔细阅读<br>static files：开放的CDN，很好用<br>iconfont：阿里的矢量图标库，非常不错，支持CDN而且支持项目<br>html5 rocks: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章<br>css tricks：如何活用CSS，以及了解CSS新特性，这里可以满足你<br>JavaScript 秘密花园 JavaScript初学必看，非常不错<br>w3cplus：一个前端学习的网站，里面的文章质量都挺不错的<br>node school：一个不错的node学习网站<br>learn git branch：一个git学习网站，交互很棒<br>前端乱炖：一个前端文章分享的社区，有很多优秀文章<br>正则表达式：一个正则表达式入门教程，非常值得一看<br>阮一峰的博客和张鑫旭的博客：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源<br>各路大牛的博客：这个太多了，就不贴了，知乎上有很全的<br>各种规范的官方网站，不懂得时候读规范</p>
<p>历程</p>
<p>以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和W3C School上的教程，以及一些前端博客，如汤姆大叔的博客。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了…</p>
<p>MrRaindrop的学习经历</p>
<p>应qiu神的邀请分享一下前端学习经验，这里对前端知识体系架构就不做总结了，各位大神们的总结已经相当到位了，我就贡献几个个人认为还比较有用的链接大家研究研究就好，然后主要分享一下我在前端学习过程中遇到的问题和总结的经验教训吧，如果能帮到想要入门的FE初学者（我就姑且假定为本文的读者受众类型了），让他们少走点弯路，每走一步都知道自己下一步的方向，这是最好了。各位大神的总结和分享详见qiu神整理的FE-learning。</p>
<p>先说下，前端这个东西每个人都可以有适合自己的学习方法，这篇仅作参考，写的有点乱，各位凑合看。</p>
<p>缘起</p>
<p>我是属于误打误撞进了前端，之前一直往做游戏的方向去来着，搞过游戏网站，玩过游戏引擎，比如unity，unreal这种商业引擎，捣鼓了几个游戏原型，不过自打研一进了实验室，直接就被导师派去写了js，导师给了我半个月时间让我写个基于百度地图api的数据展示页面，虽然这个时间还是相当宽裕的，不过之前没怎么写过js，也不会用地图api，于是我就一边啃着《Javascript权威指南》（犀牛书）一边参考实验室前人留下的“代码”，总算是把功能都写出来了。那个页面算我的js入门作了，也是我前端学习路线的开始。</p>
<p>现在想来，虽然指派了去做前端，但是一直做下去并做好还是得靠兴趣维持，当然前端是一个趣味性十足的技术领域，而且社区每天都很“热闹”。</p>
<p>项目，下一个项目</p>
<p>我个人认为前端的学习，初学阶段你可以完全脱离开书本，以项目驱动。虽然我个人是从犀牛书开始啃的，不过如果你没有充足的时间，或者觉得啃大部头乏而无味的话，还是别像我这样。当然了如果决定啃书最好是把书里的例子都跟着敲一遍的。我上研之前没接触过js，4月份还没开学呢就被直接被导师甩了个百度地图api的项目到脸上，接着就是各种ERP，地图数据展示，虽然换着花样来一点不重样，不过基本上都是前端的活，SSH和android开发也打过酱油，整个实验室就我一个人写前端敢信？富客户端SPA时代的后端就是一个restful接口，代码量基本都在前端啊，写的我一个人怎一个爽字了得…期间跟着导师感受了一把创业，每天从7点搞到晚上10点，也算是经历了一段快速成长期。</p>
<p>掌握一门技术先掌握它的大体框架，想一个能实现的点子，做一个能跑就行的demo，再去完善它的细节，等到demo完成了，对这门技术有了一个感性的认识，再去啃书，收获会大很多。我从开始原生js写到jquery，再到extjs，再到angularjs，从导师指定技术，到自己做技术选型，一个项目接着一个项目的练，就跟打怪升级似的。当然没有项目就去自己创造项目，动手实现自己的想法是件有乐趣和成就感的事。</p>
<p>收集癖和知识管理</p>
<p>前端学习有个特点，很多东西都很零碎，分散，需要你自己去整理、归纳和总结。在微博、知乎上follow了众多的大神，你不仅仅是为了听八卦，大神们的只言片语有时候留下的是无尽的余味，很有可能一个不经意提到的一个词就成为你下一个学习的目标。收集这些信息，善用google，提问，思考。就像游戏里的收集要素，前端学习也是充满搜集要素的一个“游戏”，只不过你需要一个知识管理工具来充当物品栏和仓库，我所知道的大牛们无一不是知识管理工具的重度使用者。以前用的oneNote，那时候还没绑定到云存储，现在基本上用evernote，笔记已经累计到1200+篇。书签一直打算用delicious，因为它是基于tag管理的，但一直没用起来。当然重点不在于这些工具，但是趁手的工具可以提高你的学习效率。最关键当然是随时保持旺盛的学习欲望，你的目标是了解有关前端的一切（当然不是所有都要掌握，因为毕竟你的精力有限，而且现实的说这也不太可能）。</p>
<p>跟对神</p>
<p>这个可控性貌似不大…跟对老大这个就不多说了，一定程度要看造化。不过话说回来，多跟身边的高手交流是王道，这个高手不一定要多高，但是一定要对技术有热情。研一的时候热情高涨，每天7点进实验室门，然后发现有个家伙居然比我还早到。后来发现这家伙上午就走了，下午又来了，而且导师对此习以为常，原来这家伙晚上不睡觉通宵写代码，上午才跑回去睡。后来经常和这位神讨论问题，每次感觉经验值蹭蹭蹭的往上涨。然后实验室还有一位神，被前面这位通宵神形容为“只能望其项背，一直在追赶，从来没赶上”，两位神的特点都是什么都了解一点，所以什么都能跟你讨论得起来，我有段时间做了个读书计划，从c/c++到vc/mfc再到unix网络编程，最后一路看到java核心技术和MSDN上的C#编程指南，和神们也能扯得很high了。</p>
<p>总之就是这两位神把我拉进了坑，或者说从一个坑跳进另一坑，虽然两位神都不是搞前端的，不过技术之间总有相通之处。</p>
<p>读书</p>
<p>读书，多读书，读好书。在刘未鹏的博客里看到过一个公式，你第一个月的工资等于之前买过（读过）的技术书价格总和（这里说的技术书指那些经典的公认的好书）。讨论这个公式的正确性似乎没什么意义，然而它的合理性是毋庸置疑的，那就是多读经典技术书。最极端的一个例子，google的徐宥在我的大学里面说他扫荡了图书馆的整个TP312书架…对于前端的经典书籍，后面列了一个我收集的前端书列（如果有遗漏的前端经典好书，还请留言告诉我），有条件可以尝试刷一遍这些书，我也是在找完整的时间去啃完它们。之前说的，前端知识点松散，收集零散的知识点，从博客里快速学习等，这些只是前端学习的一个方面，如果你要想深入理解一个知识体系，了解它的来龙去脉，对它建立系统认识，读经典书还是必不可少的。</p>
<p>我从最开始啃完犀牛书，然后接着去看了其他一些和前端干系不大的经典技术书，再后来通过实验室的项目和自己弄的一些小项目逐渐对前端领域比较上路以后，又看了《Javascript模式》、《Javascript设计模式》、《编写可维护的Javascript》，后来了解到node并开始用node搞点小玩意儿，又看了本《NodeJS up and run》和《Mongodb权威指南》，不过感觉前者略坑。那会儿朴灵那本深入浅出（晒书么么哒）还没出，后来出了就去图书馆借来看完，这么看下来感觉还不错，不过感觉看的还是偏少了，还需要继续刷（参照上面的书列）。</p>
<p>前端的定位</p>
<p>前端的定位关乎到你需要吸收什么样的知识和技能，决定在技术世界里你对什么需要格外敏感。如果你认为前端仅仅停留在切页面，实现交互和视觉的要求，那你对前端的认识还停留在初级阶段。阿里终面的时候我问了考官这么个问题：前端技术日新月异，范围越扩越宽，标准越来越丰富，似乎任何一个触角都能伸出很远。怎么给前端一个合适的定位？考官给我分析了半天，然后总结成一句话，就是用户和网站的联结者，用户体验的创造者（原话不是这样，但大体是这个意思）。也就是说前端的终极目标其实就是创造用户体验，提升用户体验，以用户体验为中心。不管你是从交互设计上下手，还是从性能优化出发，或者改进工作流提升工作流效率，最终都是为了创造和提升用户体验，最终都要体现到用户体验这一点上来。我认为这个总结非常有道理（当然“用户体验”这个词太宽泛了，并且不仅仅是前端工程师的范畴，比如开发后台的时候对一个数据处理过程进行优化，提升了整体性能，这也是对用户体验的一个提升）。</p>
<p>现在的前端工程师做到一定阶段不可避免会接触到很多比切页面、实现视觉要求、实现交互等更深入的问题，比如前端自动化、图像编程、性能优化等等，再往后推一点就是PHP/JSP/ASP/nodeJs，过去后端模板一般属于后端的范畴，现在随着前端架构的演进，可能会让你去写后端模板的代码，需要用到后端语言（PHP/Java/C#等），这就是所谓大前端（然而这与前端的定位并不是相背离的，大前端处理的依然是与用户接触的部分，仍然是对用户体验的优化）。可能最常见或者被谈论最多的就是node，其实这几种技术选型都可以，bat三家据说百度用PHP比较多，阿里用node比较多。</p>
<p>玉伯在他的博客里提过所谓全端是横向的，全栈是纵向的。全端即所有的终端说白了都是前端，因为都关乎到用户体验，直接和用户接触。适应多终端的开发，要求你在web前端的基础上，可能还要去扩展android开发和ios开发的知识，好在由于hybrid开发方式的流行，对使用native语言开发的技能会要求的不那么深入。</p>
<p>全栈可以说是最适合初创公司的一种发展类型，广义上认为是从前端干到后端，从开发干到运维，这种就不说了，一般人应该不会想要去往这个方向发展，想要成为这种意义上的full-stack dev的，可能用不着来看我这篇文章了；而狭义上的全栈特指使用js语言从前端写到架设在nodeJs上的后端，前后端统一语言，统一编程模型，甚至公用同一套代码。更多了解全栈开发可以看看玉伯这篇说说全栈工程师。</p>
<p>以上是我对前端以及衍生出来的技术路线的一些浅薄理解，学习一个领域掌握它的整体上的走向和趋势还是挺重要的。另外如果想要对前端学习方向、职业成长路径有一个整体的认识，推荐看看拔赤总结的这篇前端开发十日谈。</p>
<p>最后</p>
<p>贡献几个对前端学习、面试有帮助的链接：</p>
<p>前端面试问题合集（Front-end-Developer-Interview-Questions）（<a href="https://github.com/darcyclarke/Front-end-Developer-Interview-Questions）" target="_blank" rel="external">https://github.com/darcyclarke/Front-end-Developer-Interview-Questions）</a><br>前端技能汇总（JacksonTian）（<a href="https://github.com/JacksonTian/fks）" target="_blank" rel="external">https://github.com/JacksonTian/fks）</a><br>另一张前端技能汇总图（<a href="http://www.f2er.info/）" target="_blank" rel="external">http://www.f2er.info/）</a><br>前端那点事儿（书列）（<a href="http://book.douban.com/doulist/13701898/）" target="_blank" rel="external">http://book.douban.com/doulist/13701898/）</a></p>
<p>byr论坛yiyizym的建议</p>
<p>与grunt相比，学习gulp会比较简单</p>
<p>做SPA的话，推荐backbone.js和 backbone.marionette.js</p>
<p>FQ不用折腾，花十块钱买一个月的 红杏。</p>
<p>把基础打扎实了再学这些都没问题。</p>
<p>html 没什么好说的，有空学学html5。</p>
<p>css 尽量看文档 ，因为很多中文资料都各执一辞，看多了反而会糊涂。</p>
<p>有个网站可以查找html/css标签、属性在各个浏览器中的支持情况，挺好用的。</p>
<p>javascript 就看 javascript高级程序设计 。不过这么厚的书看过就会忘。对javascript核心概念的讲解：对象/原型链/ 构造函数/执行上下文/作用域链/闭包/this，这里有篇不错的文章。</p>
<p>有闲情可以看看 ecmascript 6，计划明年6月就发布啦。阮一峰的网站有入门资料。</p>
<p>jquery 有很多 API,这个网站可以方便查到。有时间弄清楚jquery deferred 的用法。</p>
<p>多给 sublimetext 装插件，比如说检查代码错误的，新建目录文件的，整理代码的。</p>
]]></content>
      
        <categories>
            
            <category> 日志 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS实现垂直居中水平居中的绝对定位居中技术]]></title>
      <url>/2017/04/26/CSS%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%B1%85%E4%B8%AD%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>###1、绝对定位居中（子元素需设置宽高）<br>内容块的父容器：position:relative;<br>子元素：position: absolute;top: 0;left: 0;bottom: 0;right: 0;margin:auto; （必须设置高度）</p>
<blockquote>
<p>原理：元素在过度受限情况下，将margin设置为auto，浏览器会重算margin的值，过度受限指的是同时设置top/bottom与height或者left/right与width。</p>
</blockquote>
<p>###2、绝对定位配合margin（子元素需设置宽高）</p>
<blockquote>
<p>原理：top：50%元素上边界位于包含框中点，设置负外边界使得元素垂直中心与包含框中心重合；</p>
</blockquote>
<p>第一种</p>
<pre><code>&lt;style&gt;
       .one{
           border: 1px solid red;
           width: 200px;height: 200px;
           position: relative;
       }
       .two{
           background: red;
           width: 100px;height: 100px
           position: absolute;left: 50%;top:50%;
           margin: -50px 0 0 -50px;          
          （margin设置百分比是相当于自身的高度与宽度）
       }
   &lt;/style&gt;
   &lt;div class=&quot;one&quot;&gt;
       &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
   &lt;/div&gt;
</code></pre><p>第二种</p>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 300px;height: 300px;
        position: relative;
    }
    .two{
        position:absolute;
        top:50%;
        left:0;
        right:0;
        margin:auto;
        margin-top:-100px; 
        （margin设置百分比是相当于自身的高度与宽度）
        width:200px;
        height:200px;
        background: red;
    }
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###3、table-cell方式（子元素不需设置宽高）<br>父容器：display:table-cell;text-align:center;vertical-align:middle;（设置宽高）<br>子元素：display:inline-block;vertical-align:middle;</p>
<blockquote>
<p>原理：利用表格布局的特点，vertical-align设置为middle;单元格中的内容与所在行中间对齐</p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
        display:table-cell;vertical-align:middle;text-align: center;
    }
    .two{
        background: red;
        (1)display:inline-block;(用此方法向上偏差2px)
        (2)margin:auto（垂直水平居中）
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;two&quot;&gt;11111111111&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###4、通过添加空span标签使图片居中（子元素需设置宽高）<br>父容器：text-align: center;</p>
<blockquote>
<p><code>&lt;span&gt;</code><br>display: inline-block;   将行内元素改变为行内块元素显示<br>width: 1px;              实现ＩＥ下可读效果<br>height: 100%;            使用元素高度和图片容器高度一样<br>vertical-align: middle;  垂直对齐<br>图片：vertical-align: middle;   </p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
        text-align: center;
    }
    span{
        display: inline-block;
        width: 1px;
        height: 100%;
        vertical-align: middle;
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;img src=&quot;../img/jian.png&quot; alt=&quot;&quot;&gt;
&lt;/div&gt;
</code></pre><p>###5、外边距margin取负数，大小为width/height（不使用box-sizing: border-box时包括padding，）的一半，再加上top: 50%; left: 50%;。<br>（子元素需设置宽高）<br>    <style><br>        .one{<br>            border: 1px solid red;<br>            width: 200px;height: 200px;<br>            position: relative;<br>        }<br>        .two{<br>            background: red;<br>            width: 30px;<br>            height: 20px;<br>            padding: 20px;<br>            position: absolute;<br>            top: 50%; left: 50%;<br>            margin-left: -35px; /<em> (width + padding)/2 </em>/<br>            margin-top: -30px; /<em> (height + padding)/2 </em>/<br>        }<br>    </style><br>    <div class="one"><br>        <span></span><br>        <div class="two"></div><br>    </div> </p>
<p>###6、内容定义transform:translate(-50%,-50%),并且加上top：50%；left：50%。（子元素需设置宽高）</p>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
        position: relative;
    }
    .two{
        background: red;
        width: 50%;
        height: 30%;
        margin: auto;
        position: absolute;
        top: 50%; left: 50%;
        -webkit-transform: translate(-50%,-50%);
        -ms-transform: translate(-50%,-50%);
        transform: translate(-50%,-50%);
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
&lt;/div&gt; 
</code></pre><p>###7、增加额外子元素设置margin-bottom为内容元素的高度+padding的一半。（不能实现水平垂直居中，仅垂直居中）</p>
<blockquote>
<p>原理与2方法类似，floater的下边界是包含框的中心线，负下外边界保证center的中心线与包含框中心线重合</p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
    }
    .floater{
        float: left;
        height: 50%;
        width: 100%;
        margin-bottom: -10%;
    }
    .two{
        clear: both;
        height: 20%;
        background: red;
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;floater&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###8、inline-block方式（子元素不需设置宽高）</p>
<blockquote>
<p>原理：为同一行的inline-block元素设置vertical-align：middle，该行内的inline-block元素会按照元素的垂直中心线对齐。</p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 300px;height: 300px;
        text-align: center;
    }
    .one:after{
        content: &apos;&apos;;
        display: inline-block;
        vertical-align: middle;
        height: 100%;
    }
    .two{
        background: red;
        display:inline-block;
        vertical-align:middle;
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;two&quot;&gt;11111111111111111111&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###9、弹性盒式布局（子元素不需设置宽高）<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes#.E5.BC.B9.E6.80.A7.E7.9B.92.E6.A6.82.E5.BF.B5" target="_blank" rel="external">CSS弹性盒</a></p>
<pre><code>&lt;style&gt;
   (1) .one{
           border: 1px solid red;
           width: 300px;height: 300px;
           display: flex;
           align-items: center;
           justify-content: center;
       }
       .two{
           background: red;
       }
   (2) .one{
           border: 1px solid red;
           width: 300px;height: 300px;
           display: flex;
       }
       .two{
           background: red;
           margin:auto;
       }
   &lt;/style&gt;
   &lt;div class=&quot;one&quot;&gt;
       &lt;div class=&quot;two&quot;&gt;111111111111&lt;/div&gt;
   &lt;/div&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> html css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[table元素]]></title>
      <url>/2017/04/26/thead/</url>
      <content type="html"><![CDATA[<p>###1、<code>&lt;thead&gt;</code><br>整个第一行的部分没有包含数据，它只是每个列的标题。因此，我们可以<code>&lt;thead</code>&gt;元素来完成这件事情，它会包裹第一个<code>&lt;tr&gt;</code>元素(它会包裹所有的行所需要的头部信息)；<br>当你使用了<code>&lt;thead&gt;</code>元素后，<code>&lt;table&gt;</code>元素中不能有直接的<code>&lt;tr&gt;</code>子元素，所有的行必须存在于<code>&lt;thead&gt;</code>，<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>里面。要注意的是我们会把所有的数据行包含在<code>&lt;tbody&gt;</code>里面。</p>
<p>###2、<code>&lt;tfoot&gt;</code><br><code>&lt;tfoot&gt;</code>独一无二的一点是它在HTML中的位置，它紧跟着<code>&lt;thead&gt;</code>并位于<code>&lt;tbody&gt;</code>的前面！你可能会认为它是table标签结束前的最后一个元素，但情况并不是这样。因为页脚可能包含了用于理解表格的必要信息，因为在资源序列中它应当排在在数据的前面。 在一些元素位置根据需要从上至下跳动的布局中，<code>&lt;tfoot&gt;</code>是个不错的技巧。举个例子，虽然一个导航在屏幕的底部，但在HTML源码中导航应该在顶部。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;   </div><div class="line">    &lt;thead&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;Name&lt;/th&gt;</div><div class="line">            &lt;th&gt;ID&lt;/th&gt;</div><div class="line">            &lt;th&gt;Favorite Color&lt;/th&gt;</div><div class="line">        &lt;/tr&gt;   </div><div class="line">    &lt;/thead&gt;   </div><div class="line">    &lt;tfoot&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;tfoot&lt;/th&gt;</div><div class="line">            &lt;th&gt;ID&lt;/th&gt;</div><div class="line">            &lt;th&gt;Favorite Color&lt;/th&gt;</div><div class="line">        &lt;/tr&gt;  </div><div class="line">    &lt;/tfoot&gt;   </div><div class="line">    &lt;tbody&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;td&gt;Jim&lt;/td&gt;</div><div class="line">            &lt;td&gt;00001&lt;/td&gt;</div><div class="line">            &lt;td&gt;Blue&lt;/td&gt;</div><div class="line">        &lt;/tr&gt;   </div><div class="line">    &lt;/tbody&gt; </div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<table><br>  <thead><br>    <tr><br>      <th>Name</th><br>      <th>ID</th><br>      <th>Favorite Color</th><br>    </tr><br>  </thead><br>  <tfoot><br>    <tr><br>      <th>tfoot</th><br>      <th>ID</th><br>      <th>Favorite Color</th><br>    </tr><br>  </tfoot><br>  <tbody><br>    <tr><br>      <td>Jim</td><br>      <td>00001</td><br>      <td>Blue</td><br>    </tr><br>  </tbody><br></table>

<p>###3、单元格：<code>td</code>和<code>th</code><br>在表格中一个独立的单元格总是<code>&lt;td&gt;</code>或<code>&lt;th&gt;</code>两者之一，只要你愿意，你可以把任何东西放进表格的单元格中，但要使这些元素成为表格中的单元格元素。<code>&lt;th&gt;</code>是“表格的标题”一般用在一列的第一格,里面的内容会自动加粗加黑他们，<code>&lt;td&gt;</code>是“表格的数据”。</p>
<p>###4、基本样式<br>你看到的大多数表格都用颜色和线条来区别表格的不同部分。边框是非常常见的。默认的，所有的单元格相互之间都有2px的空隙<br>bordercolor =”边框颜色”<br>cellspacing =”单元格之间的距离，外边距”<br>cellpadding =”单元格与内容之间的距离，内边距”<br>bgcolor =”背景颜色”<br>align =”水平对齐方式”<br>valign =”垂直对齐方式”</p>
<blockquote>
<p>1、border-collapse：<br>用于表格属性, 表示表格的两边框合并为一条。 </p>
<p>默认值：<strong>separate</strong>边框会被分开。不会忽略border-spacing 和 empty-cells 属性。<br><strong>collapse</strong>：如果可能，边框会合并为一个单一的边框。会忽略border-spacing 和 empty-cells 属性。<br><strong>inherit</strong>：规定应该从父元素继承border-collapse属性的值。</p>
<p>2、 border-spacing:<br>属性设置相邻单元格的边框间的距离（仅用于“边框分离”模式）。</p>
<p><strong>length length</strong>: 规定相邻单元的边框之间的距离。使用 px、cm 等单位。不允许使用负值。 如果定义一个 length 参数，那么定义的是水平和垂直间距。 如果定义两个 length参数，那么第一个设置水平间距，而第二个设置垂直间距。<br><strong>inherit</strong>:规定应该从父元素继承 border-spacing 属性的值。</p>
</blockquote>
<p>table表格td设置宽度后文字太多导致自动换行：<br>1.设置表格table的样式为：style=”table-layout:fixed;”<br>2.然后设置td的样式为：style=”word-wrap:break-word;”</p>
<p>###5、合并单元格<br>有两个能应用在任何单元格中的重要的属性（<code>&lt;td&gt;</code>或<code>&lt;th&gt;</code>）：colspan 和 rowspan 。他们接受任何大于等于2的正整数。如果一个 td 元素的 colspan 值为2（<code>&lt;td colspan=&quot;2&quot;&gt;</code>），它将仍然是单独的单元格，但它<br>会在一行中水平的占据两个单元格的空间。rowspan也一样，但它作用于垂直方向。</p>
<p>###6、使语义元素表现地像一个表格<br>display: table                /<em> <code>&lt;table&gt;</code>     </em>/<br>display: table-cell           /<em> <code>&lt;td&gt;</code>        </em>/<br>display: table-row            /<em> <code>&lt;tr&gt;</code>        </em>/<br>display: table-column         /<em> <code>&lt;col&gt;</code>       </em>/<br>display: table-column-group   /<em> <code>&lt;colgroup&gt;</code>  </em>/<br>display: table-footer-group   /<em> <code>&lt;tfoot&gt;</code>     </em>/<br>display: table-header-group   /<em> <code>&lt;thead&gt;</code>     </em>/</p>
<p>注意这里没有<th>的值，这是因为语义的关系，</th><th>和</th><td>的表现实际上是相同的，所以没必要多增加这样一个值。</td></p>
<p>display: inline-table<br>表格是自适应宽度的。它就像 inline-block 元素一样。顾名思义，这个值使得它们成为一个 inline-block 元素而不会产生换行。</p>
<p>###7、colgroup与col<br>colgroup、col 标签用来定义表格列的分组。<br>通过使用 <code>&lt;colgroup&gt;</code>标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。<br>如果想对 <code>&lt;colgroup&gt;</code> 中的某列定义不同的属性，请在 <code>&lt;colgroup&gt;</code> 标签内使用 <code>&lt;col&gt;</code> 标签。<br>col标签为表格中一个或多个列定义属性值。<br>colgroup标签用于对表格中的列进行组合，以便对其进行格式化。 </p>
<p>###8、“隐含”元素和未关闭的标签</p>
<ul>
<li><code>&lt;col&gt;</code>标签是属于那种无内容的不需要闭合的标签，类似<code>&lt;br&gt;/&lt;br /&gt;</code>；</li>
<li><code>&lt;td&gt;</code>元素在这些情况中是无需闭合的：“如果<td>元素后面没有更多的<code>&lt;td&gt;或&lt;th&gt;</code>元素或者在它父元素中没有更多的内容，闭合标签是可以省略的。”；</td></li>
<li>缺少的<code>&lt;/tr&gt;</code>标签的原理也是相同的：“如果<tr>元素后面没有紧跟着一个</tr><tr>元素或者如果它父元素组(<thead>,<br><tbody>或者 <tfoot>)没有更多的内容，结束标签是可以省略的。”；</tfoot></tbody></thead></tr></li>
</ul>
<p>###9、高亮鼠标所在的行/列/单元格<br>    td:hover {<br>      background: yellow;<br>    }<br>    tr:hover {<br>      background: yellow;<br>    }</p>
<pre><code>鼠标移动动一个单元格的时候他所在的列与行全部选中
var allCells = $(&quot;td, th&quot;);
allCells.on(&quot;mouseover&quot;, function() {
    var el = $(this),
        pos = el.index();
    el.parent().find(&quot;th, td&quot;).addClass(&quot;hover&quot;);
    allCells.filter(&quot;:nth-child(&quot; + (pos+1) + &quot;)&quot;).addClass(&quot;hover&quot;);
  })
  .on(&quot;mouseout&quot;, function() {
    allCells.removeClass(&quot;hover&quot;);
  });

 表格自身设置圆角时需要设置border-collapse: separate;
</code></pre>]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[apply和call]]></title>
      <url>/2017/04/26/JS%20apply%E5%92%8Ccall/</url>
      <content type="html"><![CDATA[<p>####1.        apply和call的区别在哪里</p>
<p>####2.        什么情况下用apply,什么情况下用call</p>
<p>####3.        apply的其他巧妙用法（一般在什么情况下可以使用apply）</p>
<blockquote>
<p><strong>apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.</strong> Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</p>
<p><strong>call:和apply的意思一样,只不过是参数列表不一样.</strong> Function.call(obj,[param1[,param2[,…[,paramN]]]])<br>obj：这个对象将代替Function类里this对象<br>params：这个是一个参数列表</p>
</blockquote>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    /*定义一个人类*/  
    function Person(name,age)  
    {  
        this.name=name;  
        this.age=age;  
    }  
    /*定义一个学生类*/  
    functionStudent(name,age,grade)  
    {  
        Person.apply(this,arguments);  
        this.grade=grade;  
    }  
    //创建一个学生类  
    var student=new Student(&quot;zhangsan&quot;,21,&quot;一年级&quot;);  
    //测试  
    alert(&quot;name:&quot;+student.name+&quot;\n&quot;+&quot;age:&quot;+student.age+&quot;\n&quot;+&quot;grade:&quot;+student.grade);  
    //大家可以看到测试结果name:zhangsan age:21  grade:一年级  
    //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.  
&lt;/script&gt;
</code></pre><blockquote>
<p>分析: Person.apply(this,arguments); this:在创建对象在这个时候代表的是student<br>arguments:是一个数组,也就是[“zhangsan”,”21”,”一年级”];<br>                   也就是通俗一点讲就是:用student去执行Person这个类里面的内容,在Person这个类里面存在this.name等之类的语句,这样就将属性创建到了student对象里面</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS小技巧]]></title>
      <url>/2017/04/26/JS%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>##一、金钱格式转换<br>  1.英文钱格式转换<br>    $(“#id”).text().replace(/,/g,””);<br>  2.中文钱格式转换</p>
<pre><code>function formatCash(cash){
    var str_cash = cash + &quot;&quot;;//转换成字符串
    var ret_cash = &quot;&quot;;
    var counter = 0;
    for(var i=str_cash.length-1;i&gt;=0;i--){
        ret_cash = str_cash.charAt(i) + ret_cash; //charAt返回指定位置的字符
        counter++;
        if(counter==3){
            counter = 0;
            if(i!=0){
            ret_cash = &quot;,&quot; + ret_cash;
            }
        }}
    return ret_cash;
}
</code></pre><p>##二、判断数据类型<br>  toString.call（）</p>
<pre><code>function  objType(obj) {
    return toString.call(obj).replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot; &quot;)[1];
}
</code></pre><p>##三、判断数组是否存在某个值</p>
<pre><code>Array.prototype.inArray = function(e) { 
    for(i=0;i &lt; this.length;i++)
    {
        if(this[i] == e)
        return true;
    }
    return false;
}
[1,2].inArray(1);  //true
</code></pre><p>##四、字符数统计</p>
<pre><code>function fucCheckLength(strTemp){
    var i,sum;
    sum=0;
    for(i=0;i&lt;strTemp.length;i++){
        if ((strTemp.charCodeAt(i)&gt;=0) &amp;&amp; (strTemp.charCodeAt(i)&lt;=255)){
            sum=sum+1;
        }else{
            sum=sum+2;
        }
    }
    return sum;
}
</code></pre><p>##五、三元表达式</p>
<pre><code>alert( a? &apos;true&apos; : false ? &apos;t&apos; : &apos;f&apos; ) == alert( a? &apos;true&apos; : ( false ? &apos;t&apos; : &apos;f&apos; ) )   
在js 中 语句是从右到左，所以如果a=false的时候结果：f
用法：
$(&apos;.item&apos;)[ flag ? &apos;addClass&apos; : &apos;removeClass&apos;](&apos;hover&apos;)；

flag = true 的时候：
$(&apos;.item&apos;)[&apos;addClass&apos;](&apos;hover&apos;)==$(&apos;.item&apos;).addClass(&apos;hover&apos;)
</code></pre><p>##六、 获取对象的属性个数<br>    var a{1:1,2:2,3:3,4:4}<br>    Object.getOwnPropertyNames(a).length //4</p>
<p>##七、数组和对象字面量<br>    用数组和对象字面量来代替数组和对象构造器。数组构造器很容易让人在它的参数上犯错。<br>    var a1 = new Array(x1, x2, x3); //数组长度3<br>    var a2 = new Array(x1, x2);     //数组长度2</p>
<pre><code>var a3 = new Array(x1);                                             //如果x1是一个自然数，那么它的长度将为x1
//如果x1不是一个自然数，那么它的长度将为1
</code></pre><p>##八、for循环<br>    使用for循环过程中，数组的长度，使用一个变量来接收，这样有利于代码执行效率得到提高，而不是每走一次循环，都得重新计算数组长度<br>    for(var i=0;i&lt;arr.length,i++){}<br>    优化：for(var i=0,len=arr.length;i&lt;len,i++){}</p>
<p>##九、重复的dom操作<br>    重复的dom操作，使用一个变量来进行接收很有必要，而不是频繁的去操作dom树，这对性能与代码的整洁及易维护性带来不好的影响<br>    在jquery .end()可使用的情况下应该优先使用.end()</p>
<p>##<strong>插件的一些技巧</strong></p>
<p>##一、Avalon<br>    一般情况下，我们在使用ms-controller绑定时，需要添加一个ms-controller类名，设置为visibility：hidden;目的是为了防止网速慢时将花括号暴露出来。</p>
]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript事件初识]]></title>
      <url>/2017/04/26/JavaScript%E4%BA%8B%E4%BB%B6%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p><strong>需要了解事件的什么？</strong><br>对于事件来讲，首先，我们需要了解这样几个概念：事件；事件处理程序；事件类型；事件流；事件冒泡；事件捕获；事件对象；事件方面的性能优化（事件委托、移除事件处理程序）；常见的浏览器兼容问题。</p>
<p><strong>事件的概念</strong><br>事件：指的是文档或者浏览器窗口中发生的一些特定交互瞬间。我们可以通过侦听器（或者处理程序）来预定事件，以便事件发生的时候执行相应的代码。</p>
</blockquote>
<p>###JavaScript鼠标事件</p>
<blockquote>
<p><code>onclick</code> 鼠标单击事件<br><code>ondblclick</code> 鼠标双击事件<br><code>onmousedown</code> 鼠标按下事件<br><code>onmouseup</code> 鼠标抬起事件<br><code>onmousemove</code> 鼠标移动事件<br><code>onmouseover</code> 鼠标移入事件<br><code>onmouseout</code> 鼠标移出事件</p>
</blockquote>
<p>###JavaScript键盘事件</p>
<blockquote>
<p><code>onkeyup</code> 鼠标弹起事件<br><code>onkeydown</code> 鼠标按下事件<br><code>onkeypress</code> 鼠标按下或按住</p>
</blockquote>
<p>###JavaScript表单事件</p>
<blockquote>
<p><code>onsubmit</code> 提交表单<br><code>onfocus</code> ：获取焦点事件、获取焦点的时候触发<br><code>onblur</code>： 失去焦点事件、失去焦点的时候触发<br><code>onchange</code> 改变input</p>
</blockquote>
<p>obj.focus() 给指定元素设置焦点<br>obj.blur() 取消指定元素的的焦点<br>obj.select()  这个方法是选中指定元素里面的文本内容<br>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。</p>
<p>###JavaScript页面事件<br><code>onload</code> 页面加载</p>
<p>###补充事件:<br><code>onscroll</code> 滚轮<br><code>onresize</code> 监控浏览器尺寸变化</p>
<p>###事件对象</p>
<blockquote>
<p><em>一、什么是事件对象</em><br>用来记录一些事件发生时的相关的信息的对象<br>1.只有当事件发生的时候才产生，只能在处理函数内部访问<br>2.处理函数运行结束后自动销毁。</p>
<p>当一个事件被触发时，会创建一个事件对象(Event Object),<br>这个对象里面包含了与该事件相关的属性或者方法。该对象会作为第一个参数传递给监听函数。</p>
</blockquote>
<p>###事件对象的属性</p>
<blockquote>
<p><strong><em>相对于浏览器位置的</em></strong><br>clientX 当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置<br>clientY 当鼠标事件发生的时候，鼠标相对于浏览器Y轴的位置<br><strong><em>相对于屏幕位置的</em></strong><br>screenX 当鼠标事件发生的时候，鼠标相对于屏幕X轴的位置<br>screenY 当鼠标事件发生的时候，鼠标相对于屏幕Y轴的位置<br><strong><em>相对于事件源的位置</em></strong><br>offsetX 当鼠标事件发生的时候，鼠标相对于事件源X轴的位置<br>offsetY 当鼠标事件发生的时候，鼠标相对于事件源Y轴的位置</p>
</blockquote>
<p>###事件流</p>
<blockquote>
<p>事件是与浏览器或文档交互的瞬间，如点击按钮，填写表格等，它是JS与HTML之间交互的桥梁。DOM是树形结构，如果同时给父子节点都绑定事件时，当触发子节点的时候，这两个事件的发生顺序如何决定?这就涉及到事件流的概念，它描述的是页面中接受事件的顺序。</p>
<p>当页面元素触发事件的时候，该元素的容器以及整个页面都 会按照特定顺序响应该元素的触发事件，事件传播的顺序叫 做事件流程。</p>
</blockquote>
<p>####事件流的分类<br><strong>1</strong>.冒泡型事件(所有的浏览器都支持)<br>由明确的事件源到最不确定的事件源依次向上触发。<br><strong>冒泡的案例:</strong></p>
<pre><code>&lt;div id=&quot;s1&quot;&gt;s1
     &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;
   &lt;/div&gt;
   &lt;script&gt;
     s1.addEventListener(&quot;click&quot;,function(e){
       alert(&quot;s1 冒泡事件&quot;);
     },false);
     s2.addEventListener(&quot;click&quot;,function(e){
       alert(&quot;s2 冒泡事件&quot;);
     },false);
   &lt;/script&gt;
</code></pre><p>当我们点击s2的时候，执行结果如下：<br>//s2 冒泡事件<br>//s1 冒泡事件<br><a href="http://runjs.cn/detail/kj4jgpli" target="_blank" rel="external">点击预览</a></p>
<p><strong>2</strong>.捕获型事件(IE不支持 w3c标准 火狐)<br>不确定的事件源到明确的事件源一次向下触发。<br><strong>捕获的案例</strong></p>
<pre><code>&lt;div id=&quot;s1&quot;&gt;s1
  &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  s1.addEventListener(&quot;click&quot;,function(e){
    alert(&quot;s1 捕获事件&quot;);
  },true);
  s2.addEventListener(&quot;click&quot;,function(e){
    alert(&quot;s2 捕获事件&quot;);
  },true);
&lt;/script&gt;
</code></pre><p>当我们点击s2的时候，执行结果如下：<br>//s1 捕获事件<br>//s2 捕获事件<br><a href="http://runjs.cn/detail/c3mjulm0" target="_blank" rel="external">点击预览</a></p>
<blockquote>
<p>首先在 IE 下的方法：<br>obj.attachEvent(事件名称,事件函数)<br>1、 在非标准IE下是没有事件捕获的，也就是说这个方法绑定函数，不存在事件捕获<br>2、 事件名称是带on的<br>3、 事件执行的顺序  标准IE下正序，在非标准IE下反序<br>相对应的取消事件：<br>obj.dettachEvent(事件名称,事件函数)</p>
<p>标准浏览器下 ：<br>obj.addEventListener(事件名称,事件函数,是否捕获)；<br>（ 第三个参数默认是false ：代表冒泡 true:代表捕获 ）<br>事件绑定取消 ： obj.removeEventListener(事件名称,事件函数,是否捕获), 传入的参数和绑定事件传入的参数要保持一致</p>
<p>事件的默认事件 （浏览器自带的行为，比如我们在浏览器中点击右键会弹出菜单，这就是默认行为）<br>以下是我最近用到的一个，（多级连续点击会出现一个选中的状态）以下方法可以取消掉 obj.on(“selectstart”,<br>function() {return false;});</p>
</blockquote>
<p><strong><em>事件捕获vs事件冒泡</em></strong><br>当事件捕获和事件冒泡一起存在的情况，事件又是如何触发呢。</p>
<p>这里记被点击的DOM节点为target节点<br>1、对于非target节点则先执行捕获在执行冒泡<br>2、对于target节点则是先执行先注册的事件，无论冒泡还是捕获</p>
<pre><code>&lt;div id=&quot;s1&quot;&gt;s1
  &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
s1.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s1 冒泡事件&quot;);         
},false);
s2.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s2 冒泡事件&quot;);
},false);

s1.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s1 捕获事件&quot;);
},true);

s2.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s2 捕获事件&quot;);
},true);
&lt;/script&gt;
</code></pre><p>当我们点击s2的时候,执行结果如下：<br>//s1 捕获事件<br>//s2 冒泡事件<br>//s2 捕获事件<br>//s1 冒泡事件<br><a href="http://runjs.cn/detail/fkq3uyqh" target="_blank" rel="external">点击预览</a></p>
<blockquote>
<p>这里大体分析下执行结果<br>点击 s2 ， click 事件从 document-&gt;html-&gt;body-&gt;s1-&gt;s2 (捕获前进)<br>这里在s1上发现了捕获注册事件，则输出”s1 捕获事件”<br>到达s2，已经到达目的节点，<br>s2上注册了冒泡和捕获事件，先注册的冒泡后注册的捕获，则先执行冒泡，输出”s2 冒泡事件”<br>再在s2上执行后注册的事件，即捕获事件，输出”s2 捕获事件”<br>下面进入冒泡阶段，按照 s2-&gt;s1-&gt;body-&gt;html-&gt;documen (冒泡前进)<br>在s1上发现了冒泡事件，则输出”s1 冒泡事件”</p>
</blockquote>
<p>阻止事件流(事件对象)<br>IE: 事件对象.cancelBubble=true;<br>FF: 事件对象.stopPropagation();<br>获得目标事件源的对象<br>IE： 事件对象.srcElement<br>FF: 事件对象.target<br>事件对象阻止浏览器默认行为<br>if (ev.preventDefault )<br>ev.preventDefault(); //阻止默认浏览器动作(W3C)<br>else<br>ev.returnValue = false;//IE中阻止函数器默认动作的方<br>式</p>
<blockquote>
<p>我们一般用到的都是冒泡捕获型事件 在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法。</p>
</blockquote>
<p>举个栗子？<br>假设有一个 UL 的父节点，包含了很多个 Li 的子节点：</p>
<pre><code>&lt;ul id=&quot;parent-list&quot;&gt;
  &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt;
  &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt;
  &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt;
  &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt;
  &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt;
  &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我们通常的做法是对每一个元素进行循环操作添加监听事件：</p>
<pre><code>var oUl=document.getElementById(&quot;parent-list&quot;);
var aLi=oUl.getElementsByTagName(&apos;li&apos;);
for (var i = 0; i &lt; aLi.length; i++) {
    aLi[i].onclick=function () {
        ......
    }
}
</code></pre><p>如果这个UL中的Li子元素会频繁地添加或者删除，我们就需要在每次添加Li添加事件处理函数，这就增加了复杂度和出错的可能性。</p>
<p>更简单的方法是使用事件代理机制，当事件被抛到更上层的父节点的时候，我们通过检查事件的目标对象（target）来判断并获取事件源Li。<br><strong><em>优点：</em></strong><br>1、相比之前遍历每一个li在绑定一个事件感觉爽了很多；<br>2、很明显没有了for 性能肯定是有提升；<br>3、动态的添加新的元素还是会有之前的事件（因为不管怎么样还是要冒泡到父元素的嘛）；</p>
<blockquote>
<p>为父节点添加一个click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡。父节点捕获到事件之后，通过判断e.target.nodeName来判断是否为我们需要处理的节点。并且通过e.target拿到了被点击的Li节点。从而可以获取到相应的信息，并作处理。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
