<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2017/04/29/CSS/</url>
      <content type="html"><![CDATA[<p>title: CSS实现垂直居中水平居中的绝对定位居中技术<br>date: 2017-04-28<br>tags:</p>
<ul>
<li>Html Css<br>comments: false<br>toc: true</li>
</ul>
<p>###1、绝对定位居中（子元素需设置宽高）<br>内容块的父容器：position:relative;<br>子元素：position: absolute;top: 0;left: 0;bottom: 0;right: 0;margin:auto; （必须设置高度）</p>
<blockquote>
<p>原理：元素在过度受限情况下，将margin设置为auto，浏览器会重算margin的值，过度受限指的是同时设置top/bottom与height或者left/right与width。</p>
</blockquote>
<p>###2、绝对定位配合margin（子元素需设置宽高）</p>
<blockquote>
<p>原理：top：50%元素上边界位于包含框中点，设置负外边界使得元素垂直中心与包含框中心重合；</p>
</blockquote>
<p>第一种</p>
<pre><code>&lt;style&gt;
       .one{
           border: 1px solid red;
           width: 200px;height: 200px;
           position: relative;
       }
       .two{
           background: red;
           width: 100px;height: 100px
           position: absolute;left: 50%;top:50%;
           margin: -50px 0 0 -50px;          
          （margin设置百分比是相当于自身的高度与宽度）
       }
   &lt;/style&gt;
   &lt;div class=&quot;one&quot;&gt;
       &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
   &lt;/div&gt;
</code></pre><p>第二种</p>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 300px;height: 300px;
        position: relative;
    }
    .two{
        position:absolute;
        top:50%;
        left:0;
        right:0;
        margin:auto;
        margin-top:-100px; 
        （margin设置百分比是相当于自身的高度与宽度）
        width:200px;
        height:200px;
        background: red;
    }
&lt;/style&gt;
&lt;body&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###3、table-cell方式（子元素不需设置宽高）<br>父容器：display:table-cell;text-align:center;vertical-align:middle;（设置宽高）<br>子元素：display:inline-block;vertical-align:middle;</p>
<blockquote>
<p>原理：利用表格布局的特点，vertical-align设置为middle;单元格中的内容与所在行中间对齐</p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
        display:table-cell;vertical-align:middle;text-align: center;
    }
    .two{
        background: red;
        (1)display:inline-block;(用此方法向上偏差2px)
        (2)margin:auto（垂直水平居中）
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;two&quot;&gt;11111111111&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###4、通过添加空span标签使图片居中（子元素需设置宽高）<br>父容器：text-align: center;</p>
<blockquote>
<p><code>&lt;span&gt;</code><br>display: inline-block;   将行内元素改变为行内块元素显示<br>width: 1px;              实现ＩＥ下可读效果<br>height: 100%;            使用元素高度和图片容器高度一样<br>vertical-align: middle;  垂直对齐<br>图片：vertical-align: middle;   </p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
        text-align: center;
    }
    span{
        display: inline-block;
        width: 1px;
        height: 100%;
        vertical-align: middle;
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;img src=&quot;../img/jian.png&quot; alt=&quot;&quot;&gt;
&lt;/div&gt;
</code></pre><p>###5、外边距margin取负数，大小为width/height（不使用box-sizing: border-box时包括padding，）的一半，再加上top: 50%; left: 50%;。<br>（子元素需设置宽高）<br>    <style><br>        .one{<br>            border: 1px solid red;<br>            width: 200px;height: 200px;<br>            position: relative;<br>        }<br>        .two{<br>            background: red;<br>            width: 30px;<br>            height: 20px;<br>            padding: 20px;<br>            position: absolute;<br>            top: 50%; left: 50%;<br>            margin-left: -35px; /<em> (width + padding)/2 </em>/<br>            margin-top: -30px; /<em> (height + padding)/2 </em>/<br>        }<br>    </style><br>    <div class="one"><br>        <span></span><br>        <div class="two"></div><br>    </div> </p>
<p>###6、内容定义transform:translate(-50%,-50%),并且加上top：50%；left：50%。（子元素需设置宽高）</p>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
        position: relative;
    }
    .two{
        background: red;
        width: 50%;
        height: 30%;
        margin: auto;
        position: absolute;
        top: 50%; left: 50%;
        -webkit-transform: translate(-50%,-50%);
        -ms-transform: translate(-50%,-50%);
        transform: translate(-50%,-50%);
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
&lt;/div&gt; 
</code></pre><p>###7、增加额外子元素设置margin-bottom为内容元素的高度+padding的一半。（不能实现水平垂直居中，仅垂直居中）</p>
<blockquote>
<p>原理与2方法类似，floater的下边界是包含框的中心线，负下外边界保证center的中心线与包含框中心线重合</p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 200px;height: 200px;
    }
    .floater{
        float: left;
        height: 50%;
        width: 100%;
        margin-bottom: -10%;
    }
    .two{
        clear: both;
        height: 20%;
        background: red;
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;floater&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###8、inline-block方式（子元素不需设置宽高）</p>
<blockquote>
<p>原理：为同一行的inline-block元素设置vertical-align：middle，该行内的inline-block元素会按照元素的垂直中心线对齐。</p>
</blockquote>
<pre><code>&lt;style&gt;
    .one{
        border: 1px solid red;
        width: 300px;height: 300px;
        text-align: center;
    }
    .one:after{
        content: &apos;&apos;;
        display: inline-block;
        vertical-align: middle;
        height: 100%;
    }
    .two{
        background: red;
        display:inline-block;
        vertical-align:middle;
    }
&lt;/style&gt;
&lt;div class=&quot;one&quot;&gt;
    &lt;div class=&quot;two&quot;&gt;11111111111111111111&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###9、弹性盒式布局（子元素不需设置宽高）<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes#.E5.BC.B9.E6.80.A7.E7.9B.92.E6.A6.82.E5.BF.B5" target="_blank" rel="external">CSS弹性盒</a></p>
<pre><code>&lt;style&gt;
   (1) .one{
           border: 1px solid red;
           width: 300px;height: 300px;
           display: flex;
           align-items: center;
           justify-content: center;
       }
       .two{
           background: red;
       }
   (2) .one{
           border: 1px solid red;
           width: 300px;height: 300px;
           display: flex;
       }
       .two{
           background: red;
           margin:auto;
       }
   &lt;/style&gt;
   &lt;div class=&quot;one&quot;&gt;
       &lt;div class=&quot;two&quot;&gt;111111111111&lt;/div&gt;
   &lt;/div&gt;
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客添加Fork me on GitHub]]></title>
      <url>/2017/04/28/forme/</url>
      <content type="html"><![CDATA[<p>1 . 去网址<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="external">https://github.com/blog/273-github-ribbons</a> 挑选自己喜欢的样式，并复制代码。<br>2 . 修改主题文件。以我用的next主题为例,粘贴刚才复制的代码到 themes/next/layout/_layout.swig文件中，修改后的的文件内容如下 <img src="http://op28wafvd.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170429150201.png" alt="此处输入图片的描述"></p>
<p>3 . 再把其中的链接地址改为你的github地址。如上图修改红框中地址。</p>
]]></content>
      
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript事件初识]]></title>
      <url>/2017/04/28/JavaScript%E4%BA%8B%E4%BB%B6%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>需要了解事件的什么？</strong><br>对于事件来讲，首先，我们需要了解这样几个概念：事件；事件处理程序；事件类型；事件流；事件冒泡；事件捕获；事件对象；事件方面的性能优化（事件委托、移除事件处理程序）；常见的浏览器兼容问题。</p>
<p><strong>事件的概念</strong><br>事件：指的是文档或者浏览器窗口中发生的一些特定交互瞬间。我们可以通过侦听器（或者处理程序）来预定事件，以便事件发生的时候执行相应的代码。</p>
</blockquote>
<p><strong>JavaScript鼠标事件</strong></p>
<blockquote>
<p><code>onclick</code> 鼠标单击事件<br><code>ondblclick</code> 鼠标双击事件<br><code>onmousedown</code> 鼠标按下事件<br><code>onmouseup</code> 鼠标抬起事件<br><code>onmousemove</code> 鼠标移动事件<br><code>onmouseover</code> 鼠标移入事件<br><code>onmouseout</code> 鼠标移出事件</p>
</blockquote>
<p><strong>JavaScript键盘事件</strong></p>
<blockquote>
<p><code>onkeyup</code> 鼠标弹起事件<br><code>onkeydown</code> 鼠标按下事件<br><code>onkeypress</code> 鼠标按下或按住</p>
</blockquote>
<p><strong>JavaScript表单事件</strong></p>
<blockquote>
<p><code>onsubmit</code> 提交表单<br><code>onfocus</code> ：获取焦点事件、获取焦点的时候触发<br><code>onblur</code>： 失去焦点事件、失去焦点的时候触发<br><code>onchange</code> 改变input</p>
</blockquote>
<p>obj.focus() 给指定元素设置焦点<br>obj.blur() 取消指定元素的的焦点<br>obj.select()  这个方法是选中指定元素里面的文本内容<br>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。</p>
<p><strong>JavaScript页面事件</strong><br><code>onload</code> 页面加载</p>
<p>补充事件:<br><code>onscroll</code> 滚轮<br><code>onresize</code> 监控浏览器尺寸变化</p>
<p><strong>事件对象</strong></p>
<blockquote>
<p><em>一、什么是事件对象</em><br>用来记录一些事件发生时的相关的信息的对象<br>1.只有当事件发生的时候才产生，只能在处理函数内部访问<br>2.处理函数运行结束后自动销毁。</p>
<p>当一个事件被触发时，会创建一个事件对象(Event Object),<br>这个对象里面包含了与该事件相关的属性或者方法。该对象会作为第一个参数传递给监听函数。</p>
</blockquote>
<p><strong>事件对象的属性</strong></p>
<blockquote>
<p><strong><em>相对于浏览器位置的</em></strong><br>clientX 当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置<br>clientY 当鼠标事件发生的时候，鼠标相对于浏览器Y轴的位置<br><strong><em>相对于屏幕位置的</em></strong><br>screenX 当鼠标事件发生的时候，鼠标相对于屏幕X轴的位置<br>screenY 当鼠标事件发生的时候，鼠标相对于屏幕Y轴的位置<br><strong><em>相对于事件源的位置</em></strong><br>offsetX 当鼠标事件发生的时候，鼠标相对于事件源X轴的位置<br>offsetY 当鼠标事件发生的时候，鼠标相对于事件源Y轴的位置</p>
</blockquote>
<p><strong>事件流</strong></p>
<blockquote>
<p>事件是与浏览器或文档交互的瞬间，如点击按钮，填写表格等，它是JS与HTML之间交互的桥梁。DOM是树形结构，如果同时给父子节点都绑定事件时，当触发子节点的时候，这两个事件的发生顺序如何决定?这就涉及到事件流的概念，它描述的是页面中接受事件的顺序。</p>
<p>当页面元素触发事件的时候，该元素的容器以及整个页面都 会按照特定顺序响应该元素的触发事件，事件传播的顺序叫 做事件流程。</p>
</blockquote>
<p><strong>事件流的分类</strong><br><strong>1</strong>.冒泡型事件(所有的浏览器都支持)<br>由明确的事件源到最不确定的事件源依次向上触发。<br><strong>冒泡的案例:</strong></p>
<pre><code>&lt;div id=&quot;s1&quot;&gt;s1
     &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;
   &lt;/div&gt;
   &lt;script&gt;
     s1.addEventListener(&quot;click&quot;,function(e){
       alert(&quot;s1 冒泡事件&quot;);
     },false);
     s2.addEventListener(&quot;click&quot;,function(e){
       alert(&quot;s2 冒泡事件&quot;);
     },false);
   &lt;/script&gt;
</code></pre><p>当我们点击s2的时候，执行结果如下：<br>//s2 冒泡事件<br>//s1 冒泡事件<br><a href="http://runjs.cn/detail/kj4jgpli" target="_blank" rel="external">点击预览</a></p>
<p><strong>2</strong>.捕获型事件(IE不支持 w3c标准 火狐)<br>不确定的事件源到明确的事件源一次向下触发。<br><strong>捕获的案例</strong></p>
<pre><code>&lt;div id=&quot;s1&quot;&gt;s1
  &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  s1.addEventListener(&quot;click&quot;,function(e){
    alert(&quot;s1 捕获事件&quot;);
  },true);
  s2.addEventListener(&quot;click&quot;,function(e){
    alert(&quot;s2 捕获事件&quot;);
  },true);
&lt;/script&gt;
</code></pre><p>当我们点击s2的时候，执行结果如下：<br>//s1 捕获事件<br>//s2 捕获事件<br><a href="http://runjs.cn/detail/c3mjulm0" target="_blank" rel="external">点击预览</a></p>
<blockquote>
<p>首先在 IE 下的方法：<br>obj.attachEvent(事件名称,事件函数)<br>1、 在非标准IE下是没有事件捕获的，也就是说这个方法绑定函数，不存在事件捕获<br>2、 事件名称是带on的<br>3、 事件执行的顺序  标准IE下正序，在非标准IE下反序<br>相对应的取消事件：<br>obj.dettachEvent(事件名称,事件函数)</p>
<p>标准浏览器下 ：<br>obj.addEventListener(事件名称,事件函数,是否捕获)；<br>（ 第三个参数默认是false ：代表冒泡 true:代表捕获 ）<br>事件绑定取消 ： obj.removeEventListener(事件名称,事件函数,是否捕获), 传入的参数和绑定事件传入的参数要保持一致</p>
<p>事件的默认事件 （浏览器自带的行为，比如我们在浏览器中点击右键会弹出菜单，这就是默认行为）<br>以下是我最近用到的一个，（多级连续点击会出现一个选中的状态）以下方法可以取消掉 obj.on(“selectstart”,<br>function() {return false;});</p>
</blockquote>
<p><strong><em>事件捕获vs事件冒泡</em></strong><br>当事件捕获和事件冒泡一起存在的情况，事件又是如何触发呢。</p>
<p>这里记被点击的DOM节点为target节点<br>1、对于非target节点则先执行捕获在执行冒泡<br>2、对于target节点则是先执行先注册的事件，无论冒泡还是捕获</p>
<pre><code>&lt;div id=&quot;s1&quot;&gt;s1
  &lt;div id=&quot;s2&quot;&gt;s2&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
s1.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s1 冒泡事件&quot;);         
},false);
s2.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s2 冒泡事件&quot;);
},false);

s1.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s1 捕获事件&quot;);
},true);

s2.addEventListener(&quot;click&quot;,function(e){
  alert(&quot;s2 捕获事件&quot;);
},true);
&lt;/script&gt;
</code></pre><p>当我们点击s2的时候,执行结果如下：<br>//s1 捕获事件<br>//s2 冒泡事件<br>//s2 捕获事件<br>//s1 冒泡事件<br><a href="http://runjs.cn/detail/fkq3uyqh" target="_blank" rel="external">点击预览</a></p>
<blockquote>
<p>这里大体分析下执行结果<br>点击 s2 ， click 事件从 document-&gt;html-&gt;body-&gt;s1-&gt;s2 (捕获前进)<br>这里在s1上发现了捕获注册事件，则输出”s1 捕获事件”<br>到达s2，已经到达目的节点，<br>s2上注册了冒泡和捕获事件，先注册的冒泡后注册的捕获，则先执行冒泡，输出”s2 冒泡事件”<br>再在s2上执行后注册的事件，即捕获事件，输出”s2 捕获事件”<br>下面进入冒泡阶段，按照 s2-&gt;s1-&gt;body-&gt;html-&gt;documen (冒泡前进)<br>在s1上发现了冒泡事件，则输出”s1 冒泡事件”</p>
</blockquote>
<p>阻止事件流(事件对象)<br>IE: 事件对象.cancelBubble=true;<br>FF: 事件对象.stopPropagation();<br>获得目标事件源的对象<br>IE： 事件对象.srcElement<br>FF: 事件对象.target<br>事件对象阻止浏览器默认行为<br>if (ev.preventDefault )<br>ev.preventDefault(); //阻止默认浏览器动作(W3C)<br>else<br>ev.returnValue = false;//IE中阻止函数器默认动作的方<br>式</p>
<blockquote>
<p>我们一般用到的都是冒泡捕获型事件 在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法。</p>
</blockquote>
<p>举个栗子？<br>假设有一个 UL 的父节点，包含了很多个 Li 的子节点：</p>
<pre><code>&lt;ul id=&quot;parent-list&quot;&gt;
  &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt;
  &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt;
  &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt;
  &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt;
  &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt;
  &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我们通常的做法是对每一个元素进行循环操作添加监听事件：</p>
<pre><code>var oUl=document.getElementById(&quot;parent-list&quot;);
var aLi=oUl.getElementsByTagName(&apos;li&apos;);
for (var i = 0; i &lt; aLi.length; i++) {
    aLi[i].onclick=function () {
        ......
    }
}
</code></pre><p>如果这个UL中的Li子元素会频繁地添加或者删除，我们就需要在每次添加Li添加事件处理函数，这就增加了复杂度和出错的可能性。</p>
<p>更简单的方法是使用事件代理机制，当事件被抛到更上层的父节点的时候，我们通过检查事件的目标对象（target）来判断并获取事件源Li。<br><strong><em>优点：</em></strong><br>1、相比之前遍历每一个li在绑定一个事件感觉爽了很多；<br>2、很明显没有了for 性能肯定是有提升；<br>3、动态的添加新的元素还是会有之前的事件（因为不管怎么样还是要冒泡到父元素的嘛）；</p>
<blockquote>
<p>为父节点添加一个click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡。父节点捕获到事件之后，通过判断e.target.nodeName来判断是否为我们需要处理的节点。并且通过e.target拿到了被点击的Li节点。从而可以获取到相应的信息，并作处理。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
